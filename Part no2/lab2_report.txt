***HPC CE421 Lab2 report 
***Nikitakis Panagiotis
***AEM: 1717
***email: pnikitakis@uth.gr
***4/11/2016

1)Υπάρχει στο αρχείο deviceQuery.txt

3) Μπορεί να υποστηριχθεί εικόνα μεγέθους μέχρι και 32x32 γιατί ο μέγιστος αριθμός threads σε ένα block είναι 1024 και έχουμε αντιστοιχίσει 1 thread σε 1 "pixel". 
Κρατώντας σταθερό το μέγεθος της εικόνας στα 32x32, παρατήρούμε πως καθώς αυξάνεται το μέγεθος του φίλτρου αυξάνονται (σχεδόν λογαριθμικά) τα σφάλματα σύγκρισης μεταξύ των στοιχείων της CPU και GPU (accuracy.jpg).

5) Χρησιμοποιώντας grid μπορούμε να υποστηρίξουμε πολύ μεγαλύτερα μεγέθη εικόνας, μέχρι 8192χ8192 γιάτι μετά δεν υπάρχει χώρος για την cudaMalloc πάνω στη GPU. 
Κρατώντας σταθερό το φίλτρο με ακτίνα 16, αυξάνοντας την εικόνα παρατηρούμε τον χρόνο που χρειάζεται η CPU και GPU να αυξάνονται, με την CPU να χρειάζεται περισσότερο χρόνο. Όσο αυξάνεται το μέγεθος της εικόνας τόσο αυξάνεται η διαφορά χρόνου μεταξύ CPU και GPU.(floats.jpg).
Επίσης οι διαφορές των τιμών μεταξύ  CPU και GPU αυξάνονται αλλά όχι σε μεγάλο βαθμό. 
Επομένως μεγαλύτερη σημασία στα σφάλματα έχει το μέγεθος του φιλτρου παρά της εικόνας.

6)Αλλάζοντας από floats σε double, έχουμε ίδιους χρόνους εκτέλεσης αλλά μεγάλες διαφορές στην ακρίβεια. Στο accuracy.jpg φαίνεται ξεκάθαρα πως με doubles το σφάλμα είναι περίπου 10^9 μικρότερο. 
Αυτό οφείλεται στο ότι έχουμε double-precision αποτελέσματα αντί για single-percision και μπορούμε να υποστηρίξουμε με μεγαλύτερη ακρίβεια αριθμούς.

7)	
R: filter radius
n: image height = image width	

Υποθέτω ότι έχουμε χρησιμοποιήσει padding για να αποφύγω την ακριβή μέτρηση.
Συνολικά θα χρειαστεί να διαβάσουμε n*n*(2R+1) + n*n*(2R+1) = 
2 * n^2 * (2R+1) φορές το Input και άλλες τόσες το filter. Γιατί είναι 2 kernels επί n^2 threads επί 2R+1 προσπελάσεις.

Κάθε thread κάνει 1 πολλαπλασιασμό και 1 πρόσθεση για 2R+1 φορές, άρα
οι συνολικές πράξεις θα είναι n*n*(2R+1)*2*2 και για τα 2 kernels.

Επομένως θεωρώντας πως όλα τα read είναι από την global memory τότε έχουμε λόγο προσπελάσεων προς πράξεις: 2 * n^2 * (2R+1) / n*n*(2R+1)*2*2. Άρα 1:1. 

8) Δημιούργησα ένα μεγαλύτερο πίνακα h_newInput και με αριθμητική δεικτών του εβαλα όλο το padding ίσο με μηδέν και τα εσωτερικά στοιχεία το κανονικό input. Έτρεξα 10 φορές το καινούργιο και το παλιό πρόγραμμα. 
Με if else στους kernel ο μέσος συνολικός χρόνος ήταν 0.9132ms ενώ χωρίς ήτανε 0.879ms. Επομένως υπήρξε speedup = 3.5% περίπου. Θεωρητικά θα έπρεπε να είναι πιο γρήγορο αλλά δεν ξέρω κατά πόσο πιο γρηγορο. ΑΥτό οφείλεται στο ότι όταν είχαμε if else εμφανιζόταν divergence μέσα στα warps. Δηλαδή επειδή κάποια threads παίρνουν διαφορετικό path, τελειώνουν τη δουλειά τους σε διαφορετική στιγμή από τα υπόλοιπα threads του warp.  







