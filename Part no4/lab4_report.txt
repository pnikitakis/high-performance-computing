****Nikitakis Panagiotis
****AEM: 1717
****pnikitakis@uth.gr
****5/12/2016
****HPC CE421 lab4 

(Γνωρίζω πως η εργασία-κώδικας μου είναι ανεπαρκής, αυτό έιναι λόγω έλειψης χρόνου και ασχολήθηκα μόνο τις τελευταίες μέρες. Δεν πρόλαβα να κάνω debug τον τελικό κώδικα, όπως επίσης ούτε profile με τον vtune για να προσαρμόσω threads, shared mem, grid size κτλ. Ούτε να ασχοληθώ με πιο αποδοτικούς τρόπους για το πρόβλημα. Όπως π.χ. κάθε thread να φέρνει σε κάθε tile πολλαπλά δεδομένα ή π.χ. να κάνω sorting στα data για μηδενίσω τα atomics ή π.χ. να κάνω prefix sum με Hillis Steele ή Blelloch scan ή να αποφύγω τα bank conflicts.
 
 Αρχικά χρησημοποιώ έναν kernel με grid size 1x64 και block size 1x256. Σε αυτόν έχω ένα τοπικό histogram για κάθε block στην shared memory. Έκαστο thread φέρνει ένα κομμάτι από την εικόνα που είναι στην global και το προσθέτει με atomic add στο τοπικό ιστόγραμμα. Αυτό γίνεται img_size/tile_width φορές σε tile των 256χ64 = 16384 και μετά κάθε thread προσθέτει το αντίστοιχο index του shared histogram με atomic add στο global histogram.
Μετά το mapping στο histogram equalization το κάνω στην cpu από τη στιγμή που το bin είναι μόνο 256 θέσεις και γίνεται γρηγορότερα από οτι στην gpu. 
Παίρνω το lut και το τοποθετώ στην constant γιατί δεν αλλάζει και θέλω να το χρησιμοποιώ συνέχεια και γρήγορα στον επόμενο kernel. Ο οποίος περνάει πάλι σε tile των 16384 και το αντίστοιχο index παίρνει τη τιμή από το input στην global το περνάει από το lut και το γράφει στο output στην global. 
Χρησιμοποίησα global device μετβλητή γιά το input για να μην το μεταφέρω 2 φορές μπρος πίσω.Το ίδιο και για το image size.

Επόμενο ήταν να μην μπορέσω να κρατήσω χρόνους από τη στιγμή που δεν τρέχει το πρόγραμμα.
